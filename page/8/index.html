<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/8/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/09/02/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/02/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">蒟蒻的数论笔记——积性函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-02 11:17:54" itemprop="dateCreated datePublished" datetime="2018-09-02T11:17:54+08:00">2018-09-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-03 19:52:45" itemprop="dateModified" datetime="2018-09-03T19:52:45+08:00">2018-09-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>若数论函数$f$满足如下性质，我们称$f$为积性函数：</p>
<ol>
<li>$f(1) = 1$。</li>
<li>对于任意<strong>互素</strong>正整数$n, m$有$f(nm) = f(n)f(m)$。</li>
<li>（可选项）如果对于任意正整数$n, m$都有$f(nm) = f(n)f(m)$，则称$f$为完全积性函数（没卵用）。</li>
</ol>
<h1 id="欧拉函数-varphi-n"><a href="#欧拉函数-varphi-n" class="headerlink" title="欧拉函数$\varphi(n)$"></a>欧拉函数$\varphi(n)$</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>$\varphi(n)$为不大于$n$的与$n$互素的数的个数，即：<br>$$<br>\varphi(n) = \sum_{i = 1}^n \left[\gcd(i, n) = 1\right]<br>$$</p>
<h2 id="积性证明"><a href="#积性证明" class="headerlink" title="积性证明"></a>积性证明</h2><p>我们证明对于任意正整数$n, m$若$\gcd(n, m) = 1$则$\varphi(mn) = \varphi(m)\varphi(n)$：</p>
<p>首先我们把不大于$mn$的正整数排成$m$行$n$列的表：<br>$$<br>\begin{matrix}<br>1 &amp;m + 1 &amp;\cdots &amp;(n - 1)m + 1\<br>2 &amp;m + 2 &amp;\cdots &amp;(n - 1)m + 2\<br>\vdots &amp;\vdots &amp;\ddots &amp;\vdots\<br>m &amp;2m &amp;\cdots &amp;nm<br>\end{matrix}<br>$$<br>由定义，$\varphi(mn)$为这张表中与$mn$互素的数的个数。</p>
<p>因为表中的每一行模$m$同余，因此共有$\varphi(m)$行与$m$互素。</p>
<p>我们接下来证明：每一行的$n$个数模$n$两两不同余，因为假设在第$r$行存在两个数$am+r$和$bm + r$，使得<br>$$<br>\begin{aligned}<br>am + r &amp;\equiv bm + r &amp;\pmod n \<br>(a - b)m &amp;\equiv 0 &amp;\pmod n<br>\end{aligned}<br>$$<br>因为$m,n$互素，因此$a - b \equiv 0 \pmod n$，又因为$a, b &lt; n$，因此$a = b$，矛盾。</p>
<p>因为每一行的$n$个数模$n$两两不同余，所以说虽然我不知道它们每个数模$n$是多少，但是我知道<strong>这些数模$n$一定构成了$0, 1, \cdots, n - 1$的一个排列</strong>。因此，因为$0, 1, \cdots, n-1$中有$\varphi(n)$个数与$n$互素，因此每一行中也有$\varphi(n)$个数与$n$互素。因此这$\varphi(m)$行与$m$互素的数中总共有$\varphi(m)\varphi(n)$个数与$mn$互素，因此$\varphi(mn) = \varphi(m)\varphi(n)$，证毕。</p>
<p>在刚刚的证明中有一个非常重要的思想——<strong>原来有$n$个数，对它们进行一定的变换，如果我们能够证明变换的结果两两不同，而且没变出其他的数，那么变换的结果一定是原来$n$个数的一个排列！</strong></p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="单点计算"><a href="#单点计算" class="headerlink" title="单点计算"></a>单点计算</h3><p>要探究$\varphi(n)$的计算公式，我们先探究$n = p^k$，其中$p$为素数时的特例。在前$p^k$个正整数中共有$\frac{p^k}{p} = p^{k -1}$个数是$p$的倍数与$p^k$不互素，因此：<br>$$<br>\varphi(p^k) = p^k - p^{k - 1} = p^k \left( 1 - \frac{1}{p}\right)<br>$$<br>对于单个素数$p$，有$\varphi(p) = p - 1$。</p>
<p>接下来，我们利用$\varphi$的积性把上述公式拓展到一般情况，设$n$可以被素因数分解成$n = \prod_{i = 1}^r p_i^{c_i}$的形式，那么我们就有：<br>$$<br>\begin{aligned}<br>\varphi(n) &amp;= \prod_{i = 1}^r \varphi(p_i^{c_i}) \<br>&amp;= \prod_{i = 1}^r p_i^{c_i} \left(1 - \frac{1}{p_i}\right) \<br>&amp;= \prod_{i = 1}^r p_i^{c_i} \prod_{i = 1}^r \left(1 - \frac{1}{p_i}\right) \<br>&amp;= n \prod_{i = 1}^r \left(1 - \frac{1}{p_i}\right)<br>\end{aligned}<br>$$<br>这就是欧拉函数的单点计算式，时间复杂度取决于素因数分解的时间复杂度，一般用试除法可以达到$O(\sqrt n)$。</p>
<h3 id="1-n-计算"><a href="#1-n-计算" class="headerlink" title="$[1, n]$计算"></a>$[1, n]$计算</h3><p>使用欧拉筛计算任何积性函数我们需要知道这个函数在以下三种点的取值：</p>
<ol>
<li>在素数点的取值：$\varphi(p) = p - 1$</li>
<li>对于合数$n$和它的素因子$p$在$p \mid \frac{n}{p}$时的取值：由单点计算式，$\varphi(n) = p\varphi(\frac{n}{p})$</li>
<li>对于合数$n$和它的素因子$p$在$p \nmid \frac{n}{p}$时的取值：由积性，$\varphi(n) = \varphi(p)\varphi(\frac{n}{p}) = (p - 1)\varphi(\frac{n}{p})$</li>
</ol>
<p>知道这三点信息之后我们就可以用欧拉筛完成在$O(n)$时间内计算$[1, n]$内所有欧拉函数（或其他积性函数）的值：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> phi<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> prime<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 第一条</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            phi<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第二条</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>
            phi<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三条</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="前缀和计算"><a href="#前缀和计算" class="headerlink" title="前缀和计算"></a>前缀和计算</h3><p>我们可以使用名为杜教筛的大佬专用工具在$O(n^{2 \over 3})$的时间复杂度计算出$\sum_{i = 1}^n \varphi(i)$的值。</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若正整数$a, n$互素，则$a^{\varphi(n)} \equiv 1 \pmod n$。</p>
<p><strong>证明：</strong>考虑与不大于$n$的与$n$互素的$\varphi(n)$个数：<br>$$<br>x_1, x_2, \cdots, x_{\varphi(n)}<br>$$<br>将它们同时乘以$a$：<br>$$<br>ax_1, ax_2, \cdots, ax_{\varphi(n)}<br>$$<br>因为$a$与$n$互素，因此这些数依然和$n$互素。</p>
<p>接下来我们用证明欧拉函数积性时用到的方法，证明这些数模$n$两两不同余，假设存在$x_i,x_j$，使得$ax_i \equiv ax_j \pmod n$，那么因为$a, n$互素，$x_i \equiv x_j \pmod n$，矛盾。</p>
<p>因为这些数模$n$还是那几个与$n$互素的余数，而又两两不同余，这些数一定是$x_1, x_2, \cdots, x_{\varphi(n)}$的一个排列，既然如此，我们有：<br>$$<br>\begin{aligned}<br>\prod_{i = 1}^{\varphi(n)} x_i &amp;\equiv \prod_{i = 1}^{\varphi(n)} ax_i &amp;\pmod n \<br>(a^{\varphi(n)} - 1) \prod_{i = 1}^{\varphi(n)} x_i &amp;\equiv 0 &amp;\pmod n\<br>\end{aligned}<br>$$<br>因为$\prod_{i = 1}^{\varphi(n)} x_i$与$n$互素，我们有：<br>$$<br>\begin{aligned}<br>a^{\varphi(n)} - 1 &amp;\equiv 0 &amp;\pmod n \<br>a^{\varphi(n)} &amp;\equiv 1 &amp;\pmod n<br>\end{aligned}<br>$$<br>得证。</p>
<p><strong>特例：</strong>当$n$时素数时，$\varphi(n) = n - 1$，因此我们有：<br>$$<br>a^{n - 1} \equiv 1 \pmod n<br>$$<br>即<em>费马小定理</em>。</p>
<h1 id="莫比乌斯函数-mu-n"><a href="#莫比乌斯函数-mu-n" class="headerlink" title="莫比乌斯函数$\mu(n)$"></a>莫比乌斯函数$\mu(n)$</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>设正整数$n$可以被素因数分解成$n = \prod_{i = 1}^r p_i^{c_i}$的形式，那么莫比乌斯函数的定义为：<br>$$<br>\mu(n) = \begin{cases}<br>    0 &amp; \exists 1 \le i \le r,  c_i &gt; 1 \<br>    (-1)^r &amp; \forall 1 \le i \le r, c_i \le 1<br>\end{cases}<br>$$<br>即若$n$包含<em>平方素因子</em>，则$\mu(n) = 0$，反之为$-1$的素因子个数次方。</p>
<h2 id="积性证明-1"><a href="#积性证明-1" class="headerlink" title="积性证明"></a>积性证明</h2><p>设正整数$m, n$互素，则：</p>
<ol>
<li>若其中有一个包含平方素因子（一个的函数值为$0$），则它们的积必定也包含这个平方素因子，函数值也为$0$。</li>
<li>若两个都不包含平方素因子，则由于$m, n$互素（各自有不同的素因子），它们的积必定不包含平方素因子。不同素因子个数也一定为$m, n$不同素因子个数的和。</li>
</ol>
<p>证毕。</p>
<h2 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h2><h3 id="单点计算-1"><a href="#单点计算-1" class="headerlink" title="单点计算"></a>单点计算</h3><p>见定义。</p>
<h3 id="1-n-计算-1"><a href="#1-n-计算-1" class="headerlink" title="$[1, n]$计算"></a>$[1, n]$计算</h3><p>我们依然可以用欧拉筛在$O(n)$时间内计算出不大于$n$的所有$\mu$的值，代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> mu<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> prime<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        mu<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 素数有一个素因子 (-1)^1</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            mu<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 平方素因子</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>
            mu<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>mu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 多了一个素因子 </span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="除数函数-sigma-n"><a href="#除数函数-sigma-n" class="headerlink" title="除数函数$\sigma(n)$"></a>除数函数$\sigma(n)$</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>除数函数特指一大类的函数，对于正整数$n$：<br>$$<br>\sigma_x(n) = \sum_{d \mid n} d^x<br>$$<br>$\sigma_0(n)$为$n$的约数个数，$\sigma_1(n)$为$n$的约数和。</p>
<p><strong>结论：</strong>$\sigma_0(n) \sim O(n^{1 \over \ln\ln n})$</p>
<h2 id="积性证明-2"><a href="#积性证明-2" class="headerlink" title="积性证明"></a>积性证明</h2><p>设$n, m$互素，则有：<br>$$<br>\begin{aligned}<br>\sigma_x(mn) &amp;= \sum_{d_m \mid m}\sum_{d_n \mid n} (d_nd_m)^x \<br>&amp;= \sum_{d_m \mid m} d_m^x \sum_{d_n \mid n} d_n^x \<br>&amp;= \sigma_x(m)\sigma_x(n)<br>\end{aligned}<br>$$<br>注意这里我们在展开$\sigma_x(mn)​$的时候利用了$m, n​$互素这一点，如果$m, n​$不互素则在这种写法中$mn​$的某些因子会被计算多次，假设$m, n​$有非平凡公因子$p​$，则$d_m = 1, d_n= p​$和$d_m = p, d_n = 1​$都可以令$d_md_n = p​$，$p​$就被计算了两次，结果就不对了。</p>
<h2 id="计算-2"><a href="#计算-2" class="headerlink" title="计算"></a>计算</h2><p>$\sigma$这个东西在OI中存在感极低（说白了就是没卵用），因此对计算并不做要求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/09/01/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/01/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/" class="post-title-link" itemprop="url">整除分块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-01 20:38:47" itemprop="dateCreated datePublished" datetime="2018-09-01T20:38:47+08:00">2018-09-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-02 09:03:55" itemprop="dateModified" datetime="2018-09-02T09:03:55+08:00">2018-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一维情况"><a href="#一维情况" class="headerlink" title="一维情况"></a>一维情况</h1><p>在莫比乌斯反演中，我们经常需要计算类似如下的和式：<br>$$<br>\sum_{i = 1}^n \left\lfloor \frac{n}{i} \right\rfloor<br>$$<br>如果朴素计算的话时间复杂度是$O(n)$的，这个代价对于很多多询问的题目来说是在是太高了，因此我们需要更快的方法。</p>
<p><strong>结论：</strong>$\left\lfloor \frac{n}{i} \right\rfloor$总共只有$O(\sqrt n)$种不同的取值。</p>
<p><strong>证明</strong>：我们首先证明：对于所有的$k \le \lfloor \sqrt n \rfloor$我们都可以找到一个$i$使得$\lfloor n / i \rfloor = k$：</p>
<p>令$i = \left\lfloor n / k\right\rfloor \ge k$：<br>$$<br>ik \le n &lt; (i + 1)k = ik + k \le ik + i = i(k + 1) \<br>\Rightarrow k \le n / i &lt; k + 1 \<br>\Rightarrow \left\lfloor n / i \right\rfloor = k<br>$$<br>因此，通过适当地选择$i$我们已经可以让$\lfloor n / i \rfloor$取到$\lfloor \sqrt n\rfloor$个值，因为这些$i \ge \lfloor \sqrt n\rfloor$，因此我们进一步推得：对于所有$i \ge \lfloor \sqrt n\rfloor$，$\lfloor n / i \rfloor \le \lfloor \sqrt n\rfloor$共有$\lfloor \sqrt n\rfloor$种取值。</p>
<p>对于所有的$i \le \lfloor \sqrt n \rfloor$，我们证明对于这些$i$，$\lfloor n / i \rfloor$ 的值各不相同，因为假设存在一对相邻的$i - 1, i$，使得$\lfloor {n \over i - 1} \rfloor = \lfloor {n \over i} \rfloor = k$，则：<br>$$<br>k \le {n \over i - 1} &lt; k + 1 \<br>k \le {n \over i} &lt; k + 1 \<br>\Rightarrow {n \over i - 1} - {n \over i} = {n \over i(i - 1)} &lt; 1<br>$$<br>而事实上因为$i \le \lfloor \sqrt n\rfloor$，$i(i - 1) &lt; n \Rightarrow  {n \over i(i - 1)} &gt; 1$，矛盾。</p>
<p>因此对于$i \le \lfloor \sqrt n\rfloor$的$\lfloor \sqrt n\rfloor$个$i$，$\lfloor n / i \rfloor \ge \lfloor \sqrt n\rfloor$此时也有$\lfloor \sqrt n\rfloor$种取值。</p>
<p>因此总共大约有$2\lfloor \sqrt n \rfloor$种取值，证毕。</p>
<p>这样子我们就可以一段一段地计算了，时间复杂度骤降为$O(\sqrt n)$，但是一段到底到哪里结束呢？</p>
<p><strong>结论：</strong>值为$k$的一段结束于$i = \lfloor n / k\rfloor$。</p>
<p><strong>证明：</strong>随着$i$的变大，$n / i - \lfloor n / i\rfloor$的值必定单调递减，临界点就是$n / i = \lfloor n / i\rfloor = k$，此时$i = n / k$。考虑到此时$i$可能不是整数，因此结束位置为$\lfloor n / k\rfloor$。</p>
<p><strong>推论：</strong>$i$所在的一段结束于$\lfloor n / \lfloor n / i \rfloor \rfloor$。</p>
<p>有这两条结论，我们就可以很快地计算一开头和式的值了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">;</span> l <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> l <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    r <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ans <span class="token operator">+=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h1><p>假设$n &lt; m$，我们有时候还会碰到类似如下的和式：<br>$$<br>\sum_{i = 1}^n \left\lfloor \frac{n}{i} \right\rfloor \left\lfloor \frac{m}{i} \right\rfloor<br>$$<br><strong>结论：</strong>$\left\lfloor \frac{n}{i} \right\rfloor \left\lfloor \frac{m}{i} \right\rfloor$共有$O(\sqrt n + \sqrt m)$种取值</p>
<p><strong>证明：</strong>我们可以这样想象：假设有一根数轴表示$i$的不同取值，$\left\lfloor \frac{n}{i} \right\rfloor$用$O(\sqrt n)$个分割点把数轴分成了$O(\sqrt n)$段（姑且叫它们$N$段），$\left\lfloor \frac{m}{i} \right\rfloor$用$O(\sqrt m)$个分割点在不同的位置把数轴也分成了$O(\sqrt m)$段（姑且叫它们$M$段），现在把这些段overlay一下，你会发现现在总共有$O(\sqrt n + \sqrt m)$个分割点把数轴分成了$O(\sqrt n + \sqrt m)$段，每一段的取值可能不同（想一下，两个点只有不完全在相同的$N$段和$M$段时计算出来的$\left\lfloor \frac{n}{i} \right\rfloor \left\lfloor \frac{m}{i} \right\rfloor$才可能不一样！）</p>
<p><strong>结论：</strong>$i$所在的一段结束于$\min{\lfloor n / \lfloor n / i \rfloor \rfloor, \lfloor m / \lfloor m / i \rfloor \rfloor}$。</p>
<p><strong>证明：</strong>类似一维情况。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/09/01/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/01/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">蒟蒻的数论笔记——素数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-01 17:30:31" itemprop="dateCreated datePublished" datetime="2018-09-01T17:30:31+08:00">2018-09-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-02 11:13:30" itemprop="dateModified" datetime="2018-09-02T11:13:30+08:00">2018-09-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>定义</strong>：只能被$1$和自身整除的数。</p>
<h1 id="素数的判定"><a href="#素数的判定" class="headerlink" title="素数的判定"></a>素数的判定</h1><h2 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h2><p>如果$n$不是素数那么它必定有一个不大于$\sqrt n$的因子，因此我们枚举$[1, \sqrt n]$中的所有数挨个试除即可，时间复杂度$O(\sqrt n)$，虽然慢但是保证正确。</p>
<h2 id="费马判定法"><a href="#费马判定法" class="headerlink" title="费马判定法"></a>费马判定法</h2><p>逆用费马小定理，即若$n$为素数则$a^{n - 1} \equiv 1 \pmod n$，对于一个可能的$n$我们尝试不同的$a$并判断是否符合定理，如果不是那么$n$一定不是素数，如果是，那么对于单个的$a$我们正确的概率约为$1 \over 4$，因此我们可以多试几次（比如$20$次），这样基本上就可以保证正确性了。时间复杂度就是快速幂的复杂度$O(\log n)$。</p>
<p><strong>缺点：会被卡迈克尔数干死。</strong>如果合数$n$是卡迈克尔数，那么对于所有和$n$互素的$a$，也有$a^{n - 1} \equiv 1 \pmod n$，简而言之就是费马小定理逆定理的反例。最小的卡迈克尔数是$561 = 3 \times 11 \times 17$。虽然这种数很稀少但是，在$[1, 1 \times 10^8]$之间总共有$255$个卡迈克尔数，出题人想干死你还是很简单。</p>
<h2 id="Miller-Rabin-判定法"><a href="#Miller-Rabin-判定法" class="headerlink" title="Miller-Rabin 判定法"></a>Miller-Rabin 判定法</h2><p><strong>引理</strong>：模素数$n$意义下$1$的平方根模$n$为$\pm 1$。</p>
<p><strong>证明：</strong>设此时$1$的平方根为$x$：<br>$$<br>\begin{aligned}<br>x^2 &amp;\equiv 1 &amp;\pmod n\<br>x^2 - 1 &amp;\equiv 0 &amp;\pmod n\<br>(x + 1)(x - 1) &amp;\equiv 0 &amp;\pmod n\<br>\end{aligned}<br>$$<br>因此$n\mid (x + 1)$或$n\mid (x - 1)$，即$x \equiv \pm1 \pmod n$，得证。</p>
<p>对于一个奇素数$n$，偶数$n - 1$一定可以写成$2^sd$的形式，其中$d$是奇数。我们断言对于所有$a$和某个$r$以下两个不等式必有一个成立：<br>$$<br>\begin{aligned}<br>a^d &amp;\equiv 1 &amp;\pmod n \<br>a^{2^rd} &amp;\equiv -1 &amp;\pmod n<br>\end{aligned}<br>$$<br>其中$0 &lt; a &lt; n, 0 \le r &lt; s$。</p>
<p><strong>证明：</strong>由费马小定理可得$a^{2^sd} \equiv 1 \pmod n$，我们不断地对这个式子两边开根，由引理，如果开出$-1$，那么下式成立，如果开了$s$次没开出$-1$，则上式成立。</p>
<p>Miller-Rabin 判别法基于以上命题的逆否命题，即如果存在一个$a$，使得$a^d \not \equiv 1 \pmod n$且对于所有的$0 \le r &lt; s$都有$a^{2^rd} \not\equiv -1 \pmod n$，那$n$一定不是素数。反之，$n$就<em>很有可能</em>是素数。</p>
<p>因此，Miller Rabin的工作流程如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">millerRabin</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// n > 3</span>
	<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> d <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>d <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s<span class="token operator">++</span><span class="token punctuation">,</span> d <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 分解s, d</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> K<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// K 越大越准</span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 随机一个[2, n - 2]的a</span>
		<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">qpow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a^d mod n, qpow快速幂</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> x <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 不满足逆否命题, n - 1是r = 0时的下式</span>
		<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> s <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			x <span class="token operator">=</span> x <span class="token operator">*</span> x <span class="token operator">%</span> n<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 不满足逆否命题</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要我说还是蛮复杂的，但是这个测试就已经不会被卡迈克尔数干死了。而且在$K = 1$时就已经很准了。</p>
<p>时间复杂度为$O(n\log n)$。</p>
<h2 id="自己的判定法？"><a href="#自己的判定法？" class="headerlink" title="自己的判定法？"></a>自己的判定法？</h2><p>可以通过研究素数的更多性质，例如高次剩余的特性等等发明自己的判别法，如果在复杂度允许的情况下能够在<code>int</code>范围内没问题也可以用。</p>
<h1 id="计算-1-n-的所有素数"><a href="#计算-1-n-的所有素数" class="headerlink" title="计算$[1, n]$的所有素数"></a>计算$[1, n]$的所有素数</h1><p>如何快速获得$[1, n]$的所有素数呢？如果对于$n$个数都进行以上的素数判定肯定是非常慢的，因此我们需要筛法，顾名思义，就是把不是素数的全部筛掉，那么剩下的就都是素数了。</p>
<h2 id="埃拉托色尼筛法"><a href="#埃拉托色尼筛法" class="headerlink" title="埃拉托色尼筛法"></a>埃拉托色尼筛法</h2><p>最朴素的筛法，基于的思想是如果我把每一个素数的倍数都标记成合数的话那么剩下没有标记的就是素数了，代码非常简洁，如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不是质数</span>
<span class="token keyword">int</span> prime<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
    prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        v<span class="token punctuation">[</span>i <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其复杂度应该为$\sum_{素数p \le n} \left\lfloor \frac{n}{p} \right\rfloor$。由麦腾斯定理，这个式子在$n \to \infty$时逼近$n\ln\ln n$，因此埃拉托色尼筛法的时间复杂度为$O(n\ln\ln n)$，一般$n$可以达到$10^7$。这个筛法有一个小优化我也在<a href="https://alan20210202.github.io/2018/08/21/%E7%AD%9B%E6%B3%95/">之前的笔记</a>中有提到。</p>
<p>埃拉托色尼筛法的精髓在于它利用了<strong>约数和倍数的关系是成对的</strong>这一点，将素数判断这一个枚举约数的问题转化为了枚举倍数的问题并加快了速度，这一思想十分重要，在计算狄利克雷卷积和反演的时候也会用到（把对因数求和转化为对倍数算贡献）。</p>
<h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>虽然$\ln\ln n$这个因子已经很小了，但是面对$n = 10^8$的时候还是会跪掉。因此我们需要一种筛法能够在$O(n)$的时间内筛出所有的素数。</p>
<p>我们发现埃氏筛效率欠佳的一点是：<em>一个合数会被每一个它的素因数筛掉共计好几次</em>。我们能不能让一个合数只被筛一次呢？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> v<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不是质数</span>
<span class="token keyword">int</span> prime<span class="token punctuation">[</span>P<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>欧拉筛的精髓在于那句<code>if (i % prime[j] == 0) break;</code>。</p>
<p><strong>结论：</strong>在欧拉筛中每个合数<em>会且仅会</em>被它的最小素因子筛去。</p>
<p><strong>证明：</strong>设合数$N$的最小素因子为$p_o$，因为$\frac{N}{p_0}$不可能被$p_0$更小的素数所整除，因此在循环到$i = \frac{N}{p_0}$时，内循环一定会在<code>break</code>之前筛到$\frac{N}{p_0} \cdot p_0 = N$。而假设有$N$有另外一个素因子$p_1 &gt; p_0$，则显然$p_0 \mid \frac{N}{p_1}$，因此在循环到$i = \frac{N}{p_1}$时，内循环一定会在筛到（<code>prime[j]</code>为）$p_0$之后就立刻<code>break</code>，因此一定不会再筛到$\frac{N}{p_1} \cdot p_1$。</p>
<p><strong>推论：</strong>因为合数的数量少于$n$，因此欧拉筛的复杂度为$O(n)$。</p>
<p>欧拉筛原名线性筛，冠以欧拉之名纯粹是因为我们不仅用它筛素数，还可以顺便计算以欧拉函数为首的一票积性函数。</p>
<h1 id="素因数分解"><a href="#素因数分解" class="headerlink" title="素因数分解"></a>素因数分解</h1><h2 id="试除法-1"><a href="#试除法-1" class="headerlink" title="试除法"></a>试除法</h2><p>如果$n$为合数那么$n$一定有一个不大于$\sqrt n$的素因子，因此我们枚举$[1, \sqrt n]$中的所有数挨个试除即可，时间复杂度$O(\sqrt n)$，是最常用的方法。</p>
<h2 id="Pollard’s-Rho方法"><a href="#Pollard’s-Rho方法" class="headerlink" title="Pollard’s-Rho方法"></a>Pollard’s-Rho方法</h2><p><strong>引理（生日悖论）：</strong>在$[1, N]$当中随机选出若干个数，平均需要抽出$O(\sqrt N)$个数才会抽到两个相同的数。</p>
<p><strong>简介：</strong>抽前$k - 1$个数两两不同的概率为：<br>$$<br>\frac{P(N, k - 1)}{N^{k - 1}} = \frac{N!}{(N - k+1)!N^{k-1}}<br>$$<br>如果你抽第$k$个数，与之前$k - 1$个数相同的概率为$\frac{k - 1}{N}$，因此你恰巧在刚刚抽完第$k$个数后得到两个相同的数的概率为：<br>$$<br>\frac{N!}{(N - k+1)!N^{k-1}} \cdot \frac{k - 1}{N} = \frac{(k - 1)N}{(N - k +1)!N^k}<br>$$<br>因此为了得到两个相同的数你需要抽出的数的期望是：<br>$$<br>\sum_{k = 2}^{N+1} \frac{k(k - 1)N}{(N - k +1)!N^k}<br>$$<br>它也<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/693996/average-number-of-people-required-to-find-a-pair-with-same-birthday">等价</a>于TAOCP中的：<br>$$<br>1 + \sum_{k = 1}^N \frac{N!}{(N-k)!N^k}<br>$$<br>神奇的数学家拉马努金曾对该函数进行过研究，并指出它渐进逼近$\sqrt {\frac{\pi N}{2}}$。</p>
<p>好的，现在假设我们需要分解出$n = pq$的一个非平凡因子$p$，假设我们有一个多项式同余函数$g$（例如$g(x) = (x^2 + 1) \bmod n$）。我们使用$g$来迭代生成一个<em>伪随机</em>序列${x_n}$，它和其模$p$的序列${x_n \bmod p}$相关联。由之前的生日悖论引理，前者平均在$O(\sqrt n)$次迭代后产生循环，而后者只需要$O(\sqrt p) &lt; O(\sqrt n)$次。我们可以在迭代中检测这个循环，从而完成对于素因数的分解。</p>
<p>我们知道${x_n \bmod p}$产生循环当且仅当存在$x_i, x_j$，有$x_i \equiv x_j \pmod p$，此时$x_i$和$x_j$之间就是这个序列的一个循环节，但是我们预先是不知道$p$的，那怎么判断以上条件是否成立呢？我们发现以上条件等价于$p \mid |x_i - x_j|$，因为同时$p \mid n$，所以此时$p$最大可以为$\gcd(n, |x_i - x_j|)$，因此如果我们发现$\gcd(n, |x_i - x_j|) \neq 1$我们就已经找到了一个$p = \gcd(n, |x_i - x_j|)$，非常巧妙！</p>
<p>在算法实现中，我们使用弗洛伊德判圈算法，其精髓就是环上的追及问题，我们维护两个指针$x_i, x_j$，从出发点开始$x_i$一个一个地跳，$x_j$两个两个地跳，他们的速度差为$1$，只要出现了了一个环那么在某一时刻$x_j$总是可以套$x_i$一圈！每一轮过后我们检测$\gcd(n, |x_i - x_j|) $，如果不为$1$那说明我们找到一个因子，但是如果为$n$的话就是${x_n}$和${x_n \bmod p}$一起循环了，我们的算法就GG了，需要重新选定一个出发点（给$g$的种子）。</p>
<p>这个启发式算法的复杂度取决于$O(\sqrt p)$，但是因为一般来说$p \le \sqrt n$，因此算法的复杂度平均下来是$O(n^{1 \over 4})$的，实测在<code>int</code>范围内快得飞起。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/09/01/%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/01/%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80/" class="post-title-link" itemprop="url">NOIP模拟赛 基站选址</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-09-01 13:49:02 / 修改时间：17:28:25" itemprop="dateCreated datePublished" datetime="2018-09-01T13:49:02+08:00">2018-09-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个$n$个顶点$m$条边的无向图，第$i$个节点有可靠度$r_i$，要求在节点中选取四个节点建设基站，其中有两个主基站，两个副基站。要求两个主基站必须和分别剩下的三个基站相连边，而两个副基站必须分别和两个主基站相连边。一个由两个主基站$a, b$和两个副基站$c, d$组成的基站的总可靠度定义为$(r_a + 1)(r_b + b) + r_cr_d$，求最大总可靠度。</p>
<p>$n \le 5 \times 10^4, m \le 2 \times 10^5$。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>题目要求我们寻找的四个点其实是<strong>三元环的并</strong>，主基站就是公共边的两个端点，而副基站就是公共边两侧的另外两个节点，因此，如果我们能够找出所有的三元环，并且对于每一条边维护他所在三元环相对顶点可靠度的最大和次大值，我们就可以通过枚举每一条边的方式完成最大总可靠度的计算。</p>
<p>因此，这个题目的核心就是寻找三元环，朴素的算法是$O(n^3)$的，明显不足以通过此题，因此我们要寻找复杂度更优的做法。</p>
<p><strong>我们把顶点分为两类——大点和小点</strong>，分类的依据是点的度数，如果一个顶点的度数大于$\sqrt m$就分在大点里，反之就落在小点里。我们对大点和小点分别处理。</p>
<p><strong>对于大点，我们暴力枚举每个点</strong>：</p>
<p>因为对于无向图来说，有<br>$$<br>\sum_{i = 1}^n \deg(i) = 2m<br>$$<br>因此我们可以断言：大点的数量是$O(\sqrt m)$的，因此枚举大点的时间复杂度是$O((\sqrt m)^3) = O(m\sqrt m)$。</p>
<p>在这里我们处理了全部由大点构成的三元环。</p>
<p><strong>对于小点，我们暴力枚举它的两条出边并判断对面两个点是否相连</strong>：</p>
<p>因为我们在枚举一个顶点$u$的出边的时候，显然每条边都被枚举了$\deg(u) - 1$次，所以图中小点发出的每一条边都被枚举了$O(\sqrt m)$次，总共有$O(m)$条边，因此处理小点的时间复杂度还是$O(m \sqrt m)$。</p>
<p>在这里我们处理了至少包含一个小点的三元环。</p>
<p>**合并在一起，这个算法可以找到所有的三元环，总的时间复杂度为$O(m \sqrt m)$**，虽然对于稠密图而言因为$m = O(n^2)$因此算法的复杂度还是接近$O(n^3)$，但对于题目中的图大小还是非常优秀的。</p>
<p>代码实现也不是非常复杂，使用链式前向星存图，然后额外维护数组<code>grt</code>和<code>snd</code>表示一条边所在三元环中所对点可靠值最大和次大的点的编号，再首先一个哈希表用于快速查询点和点之间的相连关系就可以了，注意常数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">50100</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">500100</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> HASH <span class="token operator">=</span> <span class="token number">1000007</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">int</span> r<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tot<span class="token punctuation">,</span> fst<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> nxt<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> to<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> deg<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> bc<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>
<span class="token keyword">int</span> big<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> small<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> grt<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> snd<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">max</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">hashEdge</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> hfst<span class="token punctuation">[</span>HASH<span class="token punctuation">]</span><span class="token punctuation">,</span> hnxt<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> hval<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> htot<span class="token punctuation">;</span>
<span class="token keyword">int</span> hl<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> hr<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	deg<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	nxt<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> fst<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
	fst<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span> to<span class="token punctuation">[</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
	hl<span class="token punctuation">[</span><span class="token operator">++</span>htot<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> hr<span class="token punctuation">[</span>htot<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
	hval<span class="token punctuation">[</span>htot<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ent <span class="token operator">=</span> <span class="token function">hashEdge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> HASH<span class="token punctuation">;</span>
	hnxt<span class="token punctuation">[</span>htot<span class="token punctuation">]</span> <span class="token operator">=</span> hfst<span class="token punctuation">[</span>ent<span class="token punctuation">]</span><span class="token punctuation">;</span>
	hfst<span class="token punctuation">[</span>ent<span class="token punctuation">]</span> <span class="token operator">=</span> htot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> 

<span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">findEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
	<span class="token keyword">int</span> ent <span class="token operator">=</span> <span class="token function">hashEdge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> HASH<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> hfst<span class="token punctuation">[</span>ent<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> hnxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>hl<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> a <span class="token operator">&amp;&amp;</span> hr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> hval<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">updateEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> grt<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">||</span> c <span class="token operator">==</span> snd<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">>=</span> r<span class="token punctuation">[</span>grt<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> snd<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> grt<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">,</span> grt<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">>=</span> r<span class="token punctuation">[</span>snd<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> snd<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">updateTriplet</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> ab<span class="token punctuation">,</span> <span class="token keyword">int</span> ac<span class="token punctuation">,</span> <span class="token keyword">int</span> bc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>ab<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>ab <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>ac<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>ac <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>bc<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">updateEdge</span><span class="token punctuation">(</span>bc <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>	
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> tot <span class="token operator">=</span> htot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>INF<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">link</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">link</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	sc <span class="token operator">=</span> bc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>deg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> small<span class="token punctuation">[</span><span class="token operator">++</span>sc<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">else</span> big<span class="token punctuation">[</span><span class="token operator">++</span>bc<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> w <span class="token operator">=</span> small<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> wu <span class="token operator">=</span> fst<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span> wu<span class="token punctuation">;</span> wu <span class="token operator">=</span> nxt<span class="token punctuation">[</span>wu<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> u <span class="token operator">=</span> to<span class="token punctuation">[</span>wu<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> wv <span class="token operator">=</span> fst<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span> wv <span class="token operator">!=</span> wu<span class="token punctuation">;</span> wv <span class="token operator">=</span> nxt<span class="token punctuation">[</span>wv<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> v <span class="token operator">=</span> to<span class="token punctuation">[</span>wv<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> uv <span class="token operator">=</span> <span class="token function">findEdge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>uv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">updateTriplet</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> wu<span class="token punctuation">,</span> wv<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> w <span class="token operator">=</span> big<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> u <span class="token operator">=</span> big<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> wu <span class="token operator">=</span> <span class="token function">findEdge</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>wu <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> v <span class="token operator">=</span> big<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> wv <span class="token operator">=</span> <span class="token function">findEdge</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> uv <span class="token operator">=</span> <span class="token function">findEdge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>wv <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> uv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
					<span class="token function">updateTriplet</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> wu<span class="token punctuation">,</span> wv<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> tot<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> to<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> to<span class="token punctuation">[</span>i <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> c <span class="token operator">=</span> grt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d <span class="token operator">=</span> snd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> d <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> r<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">*</span> r<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/09/01/%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/01/%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">NOIP模拟赛 城市规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-09-01 13:27:20 / 修改时间：16:42:03" itemprop="dateCreated datePublished" datetime="2018-09-01T13:27:20+08:00">2018-09-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$座高度为正整数的建筑物，定义不美观度为相邻建筑物高度差绝对值的最大值，你可以任意改动至多$k$座建筑物的高度，求能够达到的最小不美观度。</p>
<p>$k \le n \le 2000, h \le 2 \times 10^9$ </p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>从数据范围看出这应该是一道DP题，所以很容易陷入的一条歪路就是，定义$f[i, j]$为前$i$座建筑物修改了$j$次的最小不美观度，然后会发现没办法消除后效性<del>当场去世</del>。</p>
<p>但是如果我们把题目paraphrase一下，变成：在修改至多$k$座建筑物高度的情况下，<em>最大</em>的相邻高度差<em>最小</em>是多少？首先我们发现<strong>随着修改数增加，不美观度肯定是可以单调递减的</strong>，其次我们从这熟悉的句型就发现这其实是一道二分答案的题目，问题就变成了如何判定一个不美观度能不能达到了，我们还是需要使用DP来完成。</p>
<p>定义$f[i]$为修改前$i - 1$座建筑物但是不修改$i$的情况下为了达到我们二分的答案所需要的最小修改数，我们把它们全部初始化为$i - 1$，即最坏情况下前面的我们都需要修改。</p>
<p>接下来我们思考状态转移，设我们此时二分的答案为$x$，我们发现如果对于$j &lt; i$，如果$|h_j - h_i| \le (i - j)x$，那么就说明我们总可以通过调整$i$和$j$之间（不包括$i, j$）的$i - j - 1$座建筑物达到我们需要二分的答案。因此状态转移方程为：<br>$$<br>f[i] = \min_{1 \le j &lt; i, |h_j - h_i| \le (i - j)x} { f[j] + i - j - 1}<br>$$<br>那么最后总体上为了达到二分的答案所需要的最小修改数是多少呢？是$\min_{1 \le i \le n} {f[i]}$吗？其实并不是，因为对于$f[i]$，最坏情况下我们还需要修改$i$后面的$n - i$座建筑物，因此总的最小修改数为：<br>$$<br>\min_{1 \le i \le n} {f[i] + n - i}<br>$$<br>接下来就可以愉快的二分答案了，总的复杂度为$O(n^2\log h_{max})$，还有要注意的是如果你采用<code>int mid = (l + r) / 2</code>的话是会爆<code>int</code>的，解决方法是使用<code>int mid = l + (r - l) / 2</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">2010</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">abs</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">min</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">valid</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> h<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1ll</span> <span class="token operator">*</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>
				f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> i <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> ans <span class="token operator">=</span> INF<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> n <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> INF<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">valid</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/08/31/%E5%AF%86%E7%A0%81%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/31/%E5%AF%86%E7%A0%81%E9%94%81/" class="post-title-link" itemprop="url">NOIP模拟赛 密码锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-31 12:48:35" itemprop="dateCreated datePublished" datetime="2018-08-31T12:48:35+08:00">2018-08-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-01 16:42:32" itemprop="dateModified" datetime="2018-09-01T16:42:32+08:00">2018-09-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$把串级连接的锁（前一把的输入连接到后一把的输出），每一把锁将输入和一个操作数进行<em>与</em>，<em>或</em>，<em>异或</em>之一的二元位运算的结果作为输出，给定初始时每把锁的参数和运算类型。接下来$m$个操作共两种：</p>
<ol>
<li>查询某个数通过这一串锁的结果</li>
<li>修改某个锁的操作数和运算</li>
</ol>
<p>$n \leq 2 \times 10^5, m \leq 10^5 $，保证查询的数和操作数不超过$1000$。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>从数据范围可知正解的复杂度是$O(n\log n)$级别的，考虑其操作中又有查询又有修改，直觉上我们断定这是一道数据结构题。</p>
<p>那维护什么呢？位运算？肯定是不行的，原因就是<strong>位运算是不结合的</strong>，比如说<code>(a | b) &amp; c</code>就不一定等于<code>a | (b &amp; c)</code>，而无论是线段树还是树状数组都只能维护有结合律的代数结构，因此直接维护位运算是行不通的。</p>
<p>但是<strong>因为二元位运算的一个操作数已经给出，而且每个位的运算有互不干扰，我们可以把给定的一个二元位运算转化为若干个依赖于输入某一位的一元位运算或函数</strong>。</p>
<p>那么这样做有什么好处呢？我们看看这样的一元函数有哪些：</p>
<ol>
<li>$e$：将输入位直接输出。</li>
<li>$n$：将输入位取反输出。</li>
<li>$0$：输出恒为0。</li>
<li>$1$：输出恒为1。</li>
</ol>
<p>定义它们之间的二元运算为串联：$(f \cdot g)(x)=g(f(x))$，则有如下性质：</p>
<ol>
<li>结合律：$(f \cdot g) \cdot h = f \cdot (g \cdot h)$</li>
<li>单位元：$e$</li>
<li>封闭性：任意两个运算的复合都是这四个运算之一（自己列张表）</li>
</ol>
<p>可以看到这构成了一个<strong>幺半群</strong>，因此可以用线段树进行维护。接下来就很简单了，开$10$棵线段树分别维护每一位，然后单点修改全局查询即可。</p>
<p>代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rg</span> <span class="token expression"><span class="token keyword">register</span></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> u32<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">lch</span> <span class="token expression"><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rch</span> <span class="token expression"><span class="token punctuation">(</span>lch <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">larg</span> <span class="token expression">lch<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rarg</span> <span class="token expression">rch<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">bit</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> BITS <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">200010</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> T <span class="token operator">=</span> N <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 0</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 1</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// N</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span> <span class="token comment">// E	</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// AND</span>
	<span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// OR</span>
	<span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span> <span class="token comment">// XOR</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> t<span class="token punctuation">[</span>BITS<span class="token punctuation">]</span><span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>BITS<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ans <span class="token operator">=</span> ans <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> ch <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">;</span>
		ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> ans <span class="token operator">*</span> s<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">pushup</span><span class="token punctuation">(</span><span class="token keyword">int</span> z<span class="token punctuation">,</span> <span class="token keyword">int</span> rt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>t<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>lch<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>rch<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> z<span class="token punctuation">,</span> <span class="token keyword">int</span> rt<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		t<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">build</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> larg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">build</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> rarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pushup</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> z<span class="token punctuation">,</span> <span class="token keyword">int</span> rt<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		t<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> larg<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token function">update</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> rarg<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pushup</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"cipher.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"cipher.out"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>rg <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> tmp<span class="token punctuation">,</span> op<span class="token punctuation">;</span>
		<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%d"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">)</span> op <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">)</span> op <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> op <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>rg <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BITS<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
			a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>op<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">bit</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>rg <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BITS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">build</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> op<span class="token punctuation">;</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>op <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> tmp<span class="token punctuation">;</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>rg <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BITS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
				res <span class="token operator">|=</span> p<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">bit</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> pos<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>
			<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%s%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pos<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">)</span> op <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">)</span> op <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">else</span> op <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>rg <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> BITS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
				<span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> x<span class="token punctuation">[</span>op<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">bit</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/08/30/%E6%9C%80%E5%A4%A7m%E6%AE%B5%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/30/%E6%9C%80%E5%A4%A7m%E6%AE%B5%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5%E5%92%8C/" class="post-title-link" itemprop="url">最大多段连续子段和</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-30 19:43:21" itemprop="dateCreated datePublished" datetime="2018-08-30T19:43:21+08:00">2018-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-01 16:33:41" itemprop="dateModified" datetime="2018-09-01T16:33:41+08:00">2018-09-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题概要"><a href="#问题概要" class="headerlink" title="问题概要"></a>问题概要</h1><p>给定一个$n$个元素的环形序列（$1$号与$n$号元素相邻），元素有正有负，求$m$段连续的子段，使子段和最大，保证至少有$m$个正数。</p>
<p>$n \le 3 \times 10^5, m \le 10^5$。</p>
<h1 id="O-n-2m-暴力"><a href="#O-n-2m-暴力" class="headerlink" title="$O(n^2m)$暴力"></a>$O(n^2m)$暴力</h1><p>破环成链，类似序列上的最大连续子段和，定义$dp[i][j]$表示以$i$为右端点选了$j$段的最大子段和，<del>口胡</del>状态转移：<br>$$<br>dp[i][j] = a[i] + \max \begin{cases}<br>    dp[i - 1][j] \<br>    \max_{1 \le k &lt; i} dp[k][j - 1]<br>\end{cases}<br>$$<br>后面的$\max$随便搞搞搞成$O(1)$的，然后整个状态转移就是$O(nm)$的，加上破环成链的代价，总的时间复杂度为$O(n^2m)$，实测拿50分。</p>
<h1 id="O-n-log-n-正解"><a href="#O-n-log-n-正解" class="headerlink" title="$O(n\log n)$正解"></a>$O(n\log n)$正解</h1><p>我们发现：<strong>既然我们要选一个正数，不如把这个正数所在的一整段正数全部选了；类似地，既然我们要不选一个负数，不如把这个负数所在的一整段负数排除掉。</strong></p>
<p>于是乎我们就可以把整个环缩成若干段正负交替的“段”，假设我们缩出来是$p$段正的夹着$p$段负的，那么分情况讨论：</p>
<ol>
<li>$p \le m$，直接选所有的正数就行了，注意我们可以把这里的一段正数断成两段或更多来选，因此无论如何都能选够$m$段，此时明显最优。</li>
<li>$p &gt; m$，我们不能每一段都选了，但是我们可以假设我们先选了$p$段，然后通过或消除，或合并的方式进行“调整”。</li>
</ol>
<p>考虑调整的方式：</p>
<ol>
<li>选一段负数，这等价于把两边的正数段合并了，总段数$-1$，对答案有负贡献。</li>
<li>不选一段正数，这等价于把两边的负数段合并了，总段数$-1$，对答案也有负贡献。</li>
</ol>
<p><strong>注意：我们不能先选一段负数，然后再不选其相邻的正数（或反过来），因为这样不仅血亏，对总段数也没有影响。</strong></p>
<p>因为调整一次总段数减少1，以上的“调整”操作要进行$p - m$次。</p>
<p>既然对答案的贡献都是负的，我们把每一段的“值”变成<strong>该段数和的绝对值</strong>，然后问题就被转化为了：<strong>选择$p - m$个不相邻的数，使它们的和（对答案的负贡献）最小。</strong></p>
<p>这又是另一个经典问题了，参见<a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3620">CTSC 2007 数据备份</a>，我们维护一个小根堆，每次取出堆顶元素，并在答案上减去其的贡献，然后执行“合并”，即**如果这个数的前驱是$a$，本身是$b$，右边是$c$，我们删除$a, b, c$，然后插入一个新的权值为$a + c - b$的等效节点。这样的话，如果我们下次再选到这个节点，对答案的影响等价于我们选了$a,c$而不选$b$**。这在思想上类似于网络流的退流。为了维护前驱/后继关系，我们同时需要引入一个环形链表，总的复杂度约为$O(n\log n)$。</p>
<p>我们发现这样做环形和非环形的差别就很小了，甚至是环形的更好写（不需要处理边界情况）。</p>
<p>代码：（注意因为人懒所以用了<code>priority_queue</code><del>饮鸩止渴</del>，所以用的是懒惰删除法，还有就是代码中是大根堆维护负绝对值，本质上是一样的）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">register</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> u32<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">600100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> ans<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> pre<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> nxt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> inv<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">cmp</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> s<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> cmp<span class="token operator">></span> q<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">max</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">abs</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sgn</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ans <span class="token operator">+=</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	s<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>nxt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
	inv<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> inv<span class="token punctuation">[</span>nxt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	pre<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	nxt<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
	nxt<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> nxt<span class="token punctuation">[</span>nxt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	pre<span class="token punctuation">[</span>nxt<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		s<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>tot<span class="token punctuation">]</span> <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>tot<span class="token punctuation">]</span> <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sgn</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">sgn</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>tot<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>tot <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> tot<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> tot <span class="token operator">:</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> tot <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">abs</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	cnt <span class="token operator">=</span> tot<span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> tot <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> m<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> now <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>inv<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token function">merge</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/08/30/%E7%BA%BF%E6%80%A7%E7%AD%9B%E5%8D%A1%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/30/%E7%BA%BF%E6%80%A7%E7%AD%9B%E5%8D%A1%E5%B8%B8/" class="post-title-link" itemprop="url">线性筛卡常技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-30 13:04:41" itemprop="dateCreated datePublished" datetime="2018-08-30T13:04:41+08:00">2018-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-01 16:25:53" itemprop="dateModified" datetime="2018-09-01T16:25:53+08:00">2018-09-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>啊？卡常，没有啊？标程只是加了个小优化啊？</p>
</blockquote>
<p>于是某人的欧拉筛就在$n = 10^8$的情况下被卡常死于非命。</p>
<h1 id="素数的-6k-pm-1-判定方法"><a href="#素数的-6k-pm-1-判定方法" class="headerlink" title="素数的$6k \pm 1$判定方法"></a>素数的$6k \pm 1$判定方法</h1><p>任何正整数$n$都可以表示为$6k + r$的形式，其中$k,r$为自然数且$r \in [0, 6)$，我们讨论每一种$r$：</p>
<ol>
<li>$r = 0$：显然有$6 | n$，$n$为合数。</li>
<li>$r = 1$：$n = 6k + 1$可能是素数。</li>
<li>$r = 2$：$6k + 2 = 2(3k + 1)$，在$k \ge 1$时$n$为合数。</li>
<li>$r = 3$：$6k + 3 = 3(2k + 1)$，在$k \ge 1$时$n$为合数。</li>
<li>$r = 4$：$6k + 4 = 2(3k + 2)$，$n$为合数。</li>
<li>$r = 5$：$n = 6k + 5$可能是素数。</li>
</ol>
<p>从上述分类讨论可知：除了$2, 3$以外，所有素数都可以表示为$6k \pm 1$的形式，反之，如果$n \bmod 6 \neq \pm 1$，我们就知道$n$<strong>一定不是素数</strong>。</p>
<h1 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h1><p>在刚刚发现的$6k\pm1$判定的指导下我们就可以对欧拉筛进行常数优化了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k <span class="token operator">+=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		i <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			v<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到我们手动处理了$[2,5]$的素数，然后使用了$6k \pm 1$的结论，直接六个六个筛，但是<strong>这么筛会在一定程度上漏筛很多$2^n3^m$形式的合数，但因为这些形式的合数都是$6$的倍数，在后面筛的循环中不受影响。</strong></p>
<p><strong>这个优化仅限于我们求取$[1, n]$所有素数的情况，如果我们依赖于筛的其他副产物，如最小素因子，欧拉函数等，则该算法不正确。</strong></p>
<p>实测中加了这个优化代码能快上2倍！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/08/29/Polya/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/29/Polya/" class="post-title-link" itemprop="url">Polya计数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-29 14:31:49" itemprop="dateCreated datePublished" datetime="2018-08-29T14:31:49+08:00">2018-08-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-15 17:28:19" itemprop="dateModified" datetime="2021-03-15T17:28:19+08:00">2021-03-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>给定一串$n$个珠子组成的环链，每个珠子可以被染成黑白两色，求<strong>本质不同</strong>的染色方案的个数？</p>
<h1 id="群，置换和置换群"><a href="#群，置换和置换群" class="headerlink" title="群，置换和置换群"></a>群，置换和置换群</h1><h2 id="群的不严谨定义"><a href="#群的不严谨定义" class="headerlink" title="群的不严谨定义"></a>群的不严谨定义</h2><p>如果我们对于一个集合$G$定义一种运算$\cdot$ ，该运算满足以下性质：</p>
<ol>
<li>封闭性：$\forall a, b \in G, a \cdot b \in G$</li>
<li>结合律：$\forall a, b, c \in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$</li>
<li>单位元：$\exists e \in G, \forall a \in G, e \cdot a = a$</li>
<li>逆元：$\forall a \in G, \exists a^{-1} \in G, a \cdot a^{-1} = e$</li>
</ol>
<p>则称$(G, \cdot)$一起构成了一个<strong>群</strong>。</p>
<h2 id="置换的概念"><a href="#置换的概念" class="headerlink" title="置换的概念"></a>置换的概念</h2><p>我们抽象并拓展“变换”这个概念，定义集合$G \to G$的一个双射为一个<strong>置换</strong>，举个例子：<br>$$<br>\left(\begin{matrix}<br>1 &amp;2 &amp;3 &amp;4 \<br>2 &amp;3 &amp;4 &amp;1<br>\end{matrix}\right)<br>$$<br>这个置换表示将将集合中的$1$变成$2$，$2$变成$3$，$3$变成$4$，$4$变成$1$。</p>
<h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p>稍微想一想可知，置换是可以成群的，称为置换群，对于这个置换群我们定义的运算就是<strong>置换的复合</strong>，对于这个运算我们考察其是否满足群的性质：</p>
<ol>
<li>封闭性：大部分情况下应该是成立的</li>
<li>结合律：显然</li>
<li>单位元：$\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;\cdots \ 1 &amp;2 &amp;3 &amp; \cdots \end{matrix}\right)$</li>
<li>逆元：置换是集合到集合的<strong>双射</strong>，显然</li>
</ol>
<p>置换群的引入允许我们使用群论来处理一开始的问题，说抽象了我们刚才的问题就是：<strong>求一个序列的集合$X$，在一个置换群$G$作用下本质不同的元素个数</strong>。</p>
<h1 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h1><p>序列集合$X$在置换群$G$的作用下不同的序列数等于<strong>不动点的平均数</strong>：<br>$$<br>|X \setminus G| = \frac{1}{|G|} \sum_{g \in G} |X^g|<br>$$<br>其中$X^g = { x \in X | g(x) = x}$表示在置换$g$作用下不动点的集合，何为不动点呢？</p>
<p>例如对于置换$\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;4 \ 3 &amp;4 &amp;1 &amp; 2 \end{matrix}\right)$而言，序列$(1, 2, 1, 2)$就是它的一个不动点，因为它在置换后还是原来的样子。</p>
<p>我们接下来考察对于给定置换如何数出不动点的数目，从例子入手，比如说我们要求的是置换,$\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;4 \ 4 &amp;3 &amp;2 &amp; 1 \end{matrix}\right)$的不动点数目，我们挨个考虑这样的序列拥有什么样的性质：</p>
<ol>
<li>第一位与第四位相同</li>
<li>第二位与第三位相同</li>
<li>第三位与第二位相同</li>
<li>第四位与第一位相同</li>
</ol>
<p>显然我们最后得到了一个集合${ {1, 4}, {2, 3} }$，其中的每一个集合中的元素必须相等，考虑染色问题，对于每一组“相等”，我们可以把它整个染成两种颜色，因此这个置换共有$2^2 = 4$个不动点。</p>
<p>由于等号的传递性，如果我们逐位查看一个置换，把上下的两位并入同一个“相等集合”，那么最后我们一定会得到若干个这样的相等集合，每个“相等集合”都可以被独立地染成不同的颜色，由乘法定理，我们就得到了——</p>
<h1 id="Polya定理"><a href="#Polya定理" class="headerlink" title="Polya定理"></a>Polya定理</h1><p>$$<br>|X \backslash G| = \frac{1}{|G|} \sum_{g \in G} m^{c(g)}<br>$$</p>
<p>其中$m$是颜色个数，$c(g)$是置换$g$形成的“循环数”，一个“循环”是指某一位经过不断地置换之后最后回到自身。可以看到Polya定理其实就是我们上面的推论，不需要更多解释。</p>
<h1 id="循环同构序列计数"><a href="#循环同构序列计数" class="headerlink" title="循环同构序列计数"></a>循环同构序列计数</h1><p>终于进入了我们的正题，循环同构序列计数，到这一步我们终于可以解答一开始的问题了：</p>
<p>Polya定理的精髓就在于求出一个置换的循环数，而朴素的枚举显然是不够的，我们考察所谓“循环同构”背后依赖的哪些置换，比如说对于一个长度为$4$的序列，以下置换后它与自身是循环同构的：<br>$$<br>\left(\begin{matrix}<br>    1 &amp;2 &amp;3 &amp;4 \<br>    2 &amp;3 &amp;4 &amp;1<br>\end{matrix}\right),<br>\left(\begin{matrix}<br>    1 &amp;2 &amp;3 &amp;4 \<br>    3 &amp;4 &amp;1 &amp;2<br>\end{matrix}\right),<br>\left(\begin{matrix}<br>    1 &amp;2 &amp;3 &amp;4 \<br>    4 &amp;1 &amp;2 &amp;3<br>\end{matrix}\right),<br>\left(\begin{matrix}<br>    1 &amp;2 &amp;3 &amp;4 \<br>    1 &amp;2 &amp;3 &amp;4<br>\end{matrix}\right)<br>$$<br>我们发现一个循环同构的置换就是把它的<em>后面全部移到前面来，前面几位补到后面去</em>。</p>
<p>为了接下来的推导方便我们让位数起始于$0$。</p>
<p>那么，对于一个偏移了$k$的置换，第$a$位被置换之后就到了$(a + k) \bmod n$的位置，其中$n$为序列长度，而对于一个长度为$l$的完整循环来说，它必须满足：</p>
<p>$$<br>\begin{aligned}<br>a + kl &amp;\equiv a &amp;\pmod{n} \<br>kl &amp;\equiv 0 &amp;\pmod{n}<br>\end{aligned}<br>$$<br>显然当$kl = \operatorname{lcm}(k, n)$的时候$l$有最小值$\frac{\operatorname{lcm}(k, n)}{k}$。由于每一位都偏移了$k$位，因此置换中每个循环的长度都是相等的，而因为每个循环都cover了$l$个元素，因此循环的个数为：<br>$$<br>\begin{aligned}<br>\frac{n}{l} &amp;= \frac{n}{\frac{\operatorname{lcm}(k, n)}{k}} \<br>&amp;= \frac{kn}{\operatorname{lcm}(k, n)} \<br>&amp;= \gcd(k, n)<br>\end{aligned}<br>$$<br>这个发现让我们免于枚举每个循环置换，相反，我们枚举$\gcd(k, n)$的每一个取值$d$，即$n$的因数，统计出$\gcd(k, n) = d$的所有$k$的个数，依Polya定理统一累加到答案上。</p>
<p>那怎么统计呢？枚举？</p>
<p>我们发现$\gcd(k, n) = d$等价于$\gcd({k \over d}, {n \over d}) = 1$，即小于$n \over d$的与$n \over d$互质的数个数，这显然等于$\varphi({n \over d})$。</p>
<p>因此最后的答案就是：</p>
<p>$$<br>\sum_{d|n} \varphi\left(\frac{n}{d}\right)m^d<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2018/08/28/%E6%9C%89%E9%99%90%E5%BE%AE%E7%A7%AF%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/28/%E6%9C%89%E9%99%90%E5%BE%AE%E7%A7%AF%E5%88%86/" class="post-title-link" itemprop="url">有限微积分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-28 17:34:17" itemprop="dateCreated datePublished" datetime="2018-08-28T17:34:17+08:00">2018-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-09-04 22:34:48" itemprop="dateModified" datetime="2019-09-04T22:34:48+08:00">2019-09-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>微积分是数学分析中一类极为有力的工具，其中微分的核心是微分算子$D$，定义为：<br>$$<br>Df(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}<br>$$<br>若$DF(x) = f(x)$我们称$F(x)$是$f(x)$的原函数，他们两个一起构成了积分的核心——牛顿-莱布尼茨公式：<br>$$<br>\int_a^b f(x)dx = F(b) - F(a)<br>$$<br>在微积分当中我们有一整套系统的规则来方便地计算各种形式的微分和积分，而依稀记得一句话：<strong>积分是黎曼和的极限</strong>，即积分是求和的连续情况，求和是积分的离散情况，既然我们可以系统地计算积分，那么我们可不可以系统地计算和式呢？答案是肯定的，《具体数学》中为我们引入的一类工具便是——<strong>有限微积分</strong>。（个人觉得叫离散微积分更好？）</p>
<h1 id="定义和记号"><a href="#定义和记号" class="headerlink" title="定义和记号"></a>定义和记号</h1><p>仿照微分算子$D$的定义我们首先定义差分算子$D$：<br>$$<br>\Delta f(x) = f(x + 1) - f(x)<br>$$<br>可以发现，差分算子本质是微分算子定义中$h = 1$的特例，只不过在微分中$h$无限接近于0，而在差分当中最小只能为1。</p>
<p>类似地，若$\Delta F(x) = f(x)$我们也可以称$F(x)$是$f(x)$的“原函数”，显然我们有：<br>$$<br>\sum_a^b f(x) \delta x  = F(b) - F(a)<br>$$<br>我们在这里仿照定积分引入了一个新的记号$\sum_a^b f(x)\delta x$，不难发现：<br>$$<br>\sum_a^b f(x) \delta x = \sum_{x = a}^{b - 1}f(x)<br>$$<br>类似地，仿照不定积分的定义，我们还可以定义一个更为抽象的概念”不定和式“，即<br>$$<br>\sum f(x) \delta x = F(x) + C<br>$$<br>$C$也起类似积分常数的作用。</p>
<h1 id="注入灵魂"><a href="#注入灵魂" class="headerlink" title="注入灵魂"></a>注入灵魂</h1><p>照葫芦画瓢到此为止，然而如果只有这么些记号是没有卵用的，就像你不能只靠微分的极限定义和莱布尼茨公式计算微积分一样，我们也不能指望靠这些记号就可以快速计算和式了，我们还需要类似于微积分当中的幂法则等一系列规则的支持。</p>
<p>首先不证自明的一点是：<strong>在有限微积分中，差分算子对于加法和减法的分配率成立</strong>。</p>
<h2 id="幂法则"><a href="#幂法则" class="headerlink" title="幂法则"></a>幂法则</h2><p>我们先考察微积分当中的幂法则在这里有没有等价的替代品，众所周知，幂法则是：<br>$$<br>Dx^m = mx^{m-1}<br>$$<br>如果简单地把微分算子换成差分我们会得到：<br>$$<br>\Delta x^m = (x + 1)^m - x^m<br>$$<br>接下来的展开势必就要用到二项式定理了，事到如今只要是正常人都知道最后是得不到$ mx^{m-1} $的，我们发现直接把幂法则照搬过来是行不通的，如果问题不是出在差分算子上那就是出在“幂”上了，那么现在问题变成了：<strong>我们能不能找到一种“幂”的定义，使它在差分算子作用下表现出类似幂法则的性质呢？</strong></p>
<p>答案是肯定的，这种“幂”被称作下降阶乘幂，记作$x^{\underline m}$，《具体数学》中对它的定义是：<br>$$<br>x^{\underline m} = x(x - 1)(x - 2)\cdots(x - m + 1)<br>$$<br>显然无论是从形式还是从名字来看它都有一个更简洁的阶乘定义：<br>$$<br>x^{\underline m} = \frac{x!}{(x - m)!}<br>$$<br>在《具体数学》中作者花了不少笔墨来把它最上面的定义推广到$m &lt; 0$的情形，但是一切在阶乘定义中就很显然了，对于$m &gt; 0$，我们有：<br>$$<br>x^{\underline{-m}} = \frac{1}{(x + 1)(x + 2)\cdots(x + m)}<br>$$<br>我们也有类似$x^{m + n} = x^mx^n$的规则：<br>$$<br>x^{\underline{m + n}} = x^{\underline m}(x - m)^{\underline n}<br>$$<br>好的，让我们回到幂法则，那么如果我们结合下降阶乘幂和差分算子，我们会得到什么呢？<br>$$<br>\begin{aligned}<br>\Delta x^{\underline m} &amp;= (x + 1)^{\underline m} - x^{\underline m} \<br>&amp;= \frac{(x + 1)!}{(x + 1 - m)!} - \frac{x!}{(x - m)!} \<br>&amp;= \frac{(x + 1)! - (x + 1 - m)x!}{(x + 1 - m)!} \<br>&amp;= \frac{x![(x + 1) - (x + 1 - m)]}{(x + 1 - m)!} \<br>&amp;= \frac{mx!}{[x - (m - 1)]!} \<br>&amp;= mx^{\underline{m - 1}}<br>\end{aligned}<br>$$<br>我们成功地推出了“幂法则”！</p>
<p>顺带一提，除了下降阶乘幂之外还有上升阶乘幂，定义为$x^{\overline m} = \frac{(x + m - 1)!}{(x - 1)!}$，也有类似幂法则的性质，但是用起来比较麻烦，故我们使用下降阶乘幂。</p>
<p>既然我们已经成功导出了有限微积分中差分算子的幂法则，那么对于不定和式，其幂法则也呼之欲出：<br>$$<br>\sum x^{\underline m}\delta x = \frac{x^{\underline{m + 1}}}{m + 1} + C<br>$$<br>正如积分中对于幂法则在$m = -1$的时候需要特殊处理，即$\int x^{-1} dx = \ln x + C$，在求和当中，我们也有类似的：<br>$$<br>\sum x^{\underline{-1}}\delta x = H_x + C<br>$$<br>其中$H_x$表示调和级数的第$x$项部分和，我们知道当$x \to \infty$时有$H_x = \ln x + \gamma$，其中$\gamma$是欧拉-马歇罗尼常数。从此我们也可以看出上述规则确实是积分中对应公式的一个离散模拟。</p>
<p>那么这些法则有什么用呢？我们可以再试试看求解如下和式：<br>$$<br>\sum_{x = 1}^n x^2<br>$$<br>我在先前成套方法的介绍中曾利用成套方法对它进行过求解，过程相对来说比较繁琐，我们看看怎么用有限微积分秒杀这道题。</p>
<p>首先，注意到：<br>$$<br>x^2 = x^{\underline 2} + x^{\underline 1}<br>$$<br>所以：<br>$$<br>\begin{aligned}<br>\sum x^2 \delta x &amp;= \sum x^{\underline 2}\delta x + \sum x^{\underline 1}\delta x \<br>&amp;= \frac{x^{\underline 3}}{3} + \frac{x^{\underline 2}}{2} + C \<br>&amp;= \frac{2x(x - 1)(x - 2) + 3x(x - 1)}{6} + C \<br>&amp;= \frac{x(x - 1)(2x - 1)}{6} + C<br>\end{aligned}<br>$$<br>接下来就是展现真正技术的时刻：<br>$$<br>\begin{aligned}<br>\sum_{x = 1}^n x^2 &amp;= \sum_1^{n + 1} x^2 \delta x \<br>&amp;= \frac{n(n + 1)(2n + 1)}{6} + C - \frac{1 \cdot 0 \cdot 1}{6} - C \<br>&amp;= \frac{n(n + 1)(2n + 1)}{6}<br>\end{aligned}<br>$$<br>就非常舒服。<strong>通过归纳法可以证明，对于任何多项式，我们总是可以把它转换为若干个下降阶乘幂的线性组合</strong>，因此，对于一切多项式的和式，我们都能用有限微积分系统地求取！</p>
<p><strong>运用指数为$-2$的幂法则，你就会发现你得到了所谓的裂项公式。</strong></p>
<h2 id="e-x-的对等"><a href="#e-x-的对等" class="headerlink" title="$e^x$的对等"></a>$e^x$的对等</h2><p>在微积分中，$e^x$的具有非常好的性质，即导数和积分都等于自身，那么在有限微积分当中有没有类似的函数呢，幸运的是，找到这样的函数并不困难：<br>$$<br>\begin{aligned}<br>\Delta f(x) &amp;= f(x) \<br>f(x + 1) - f(x) &amp;= f(x) \<br>f(x + 1) &amp;= 2f(x)<br>\end{aligned}<br>$$<br>这就很明显了，$f(x) = 2^x$，或者对其平移的结果都满足差分等于自身的性质。</p>
<p>因此，无惑乎我们有：<br>$$<br>\begin{aligned}<br>\sum_{x = 1}^n 2^x &amp;= \sum_1^{n + 1} 2^x \delta x \<br>&amp;= 2^{n + 1} - 2^0 \<br>&amp;= 2^{n + 1} - 1<br>\end{aligned}<br>$$</p>
<h2 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h2><p>我们知道在微积分当中：<br>$$<br>\int a^xdx = \frac{a^x}{\ln a} + C<br>$$<br>我们接下来探究在有限微积分当中是否有类似结论的出现，我们先猜想：<br>$$<br>\sum a^x\delta x = ka^x + C<br>$$<br>两边取差分：<br>$$<br>\begin{aligned}<br>a^x &amp;= ka^{x + 1} - ka^x \<br>a^x &amp;= ka^x(a - 1) \<br>k &amp;= \frac{1}{a - 1}<br>\end{aligned}<br>$$<br>因此：<br>$$<br>\sum a^x\delta x = \frac{a^x}{a - 1} + C<br>$$<br><strong>使用这一规则可以直接推出等比数列求和公式</strong>。</p>
<h2 id="其他法则？"><a href="#其他法则？" class="headerlink" title="其他法则？"></a>其他法则？</h2><p>我们要不要把链式法则，积法则，商法则之类的全部搬到有限微积分里面了呢？其实是不用的，因为这些法则都是辅助我们计算微分的，其存在的原因便是使用微分的极限定义计算导数实在是太困难了，而差分算子则不然，计算一个函数的差分只要代进去就行了。</p>
<p>但是，为了后文的方便，在此我们着重来讨论积法则在有限微积分当中的对等，在微积分当中，积法则是：<br>$$<br>D(uv) = uDv + vDu<br>$$<br>那么在有限微积分当中：<br>$$<br>\begin{aligned}<br>\Delta(u(x)v(x)) &amp;= u(x + 1)v(x + 1) - u(x)v(x) \<br>&amp;= u(x + 1)v(x + 1) - u(x)v(x + 1) + u(x)v(x + 1) - u(x)v(x) \<br>&amp;= u(x)\Delta v(x) + v(x + 1)\Delta u(x)<br>\end{aligned}<br>$$<br>记移进算子$Ef(x) = f(x + 1)$，则有限微积分的积法则可以被表示为：<br>$$<br>\begin{aligned}<br>\Delta(uv) &amp;= u\Delta v + Ev\Delta u \<br>&amp;= Eu\Delta v + v\Delta u<br>\end{aligned}<br>$$</p>
<h1 id="分部求和"><a href="#分部求和" class="headerlink" title="分部求和"></a>分部求和</h1><p>对于积分，我们有分部积分公式：<br>$$<br>\int udv = uv - \int vdu<br>$$<br>其本质是对微分积法则移项并两边积分得到的成果，我们能不能也用上面推导出的有限微积分的“积法则”推导出分部求和呢？<br>$$<br>\begin{aligned}<br>\Delta(uv) &amp;= u\Delta v + Ev\Delta u \<br>\Rightarrow u\Delta v &amp;= \Delta(uv) - Ev\Delta u \<br>\Rightarrow \sum u \Delta v &amp;= uv - \sum Ev\Delta u<br>\end{aligned}<br>$$<br>最后的结果就是分部求和的公式，分部积分的经典例题是$\int xe^xdx$，对应到有限微积分当中就是$\sum x2^x\delta x$，运用我们刚得到的分部求和公式，令$u = x, \Delta u = 1, v = 2^x, \Delta v = 2^x$我们就得到了：<br>$$<br>\begin{aligned}<br>\sum x2^x\delta x &amp;= x2^x - \sum 2^{x + 1}\delta x + C\<br>&amp;=x2^x - 2^{x + 1} + C<br>\end{aligned}<br>$$<br>因此<br>$$<br>\begin{aligned}<br>\sum_{i = 0}^nx2^x &amp;= \sum_0^{n + 1} x2^x\delta x \<br>&amp;= (n + 1)2^{n + 1} - 2^{n + 2} - 0\cdot 1 + 2 \<br>&amp;= (n - 1)2^{n + 1} + 2<br>\end{aligned}<br>$$<br>计算这个和式甚至不需要思考！</p>
<p>我们来试试上次成套方法博客中我说需要一定技巧的$\sum_{x = 1}^n (-1)^xx^2$吧！</p>
<p>令$u = x^2, \Delta v = (-1)^x$可得$\Delta u = 2x + 1, v = -\frac{ (-1)^x}{2}$：<br>$$<br>\begin{aligned}<br>\sum (-1)^xx^2\delta x &amp;= -\frac{x^2(-1)^x}{2} - \sum-\frac{ (-1)^{x + 1}}{2}(2x + 1)\delta x + C\<br>&amp;= -\frac{x^2(-1)^x}{2} - \sum\frac{(-1)^x(2x + 1)}{2}\delta x + C\<br>&amp;= -\frac{x^2(-1)^x}{2} - \sum\frac{(2x + 1)}{2}(-1)^x\delta x + C<br>\end{aligned}<br>$$<br>观察这个式子的后项，我们故技重施，令$u = \frac{(2x + 1)}{2}, \Delta u = 1, \Delta v = (-1)^x$：<br>$$<br>\begin{aligned}<br>\sum\frac{(2x + 1)}{2}(-1)^x\delta x &amp;= -\frac{(2x + 1)(-1)^x}{4} - \sum-\frac{ (-1)^{x + 1}}{2}\delta x + C\<br>&amp;= -\frac{(2x + 1)(-1)^x}{4} - \frac{1}{2}\sum(-1)^x\delta x + C\<br>&amp;= -\frac{(2x + 1)(-1)^x}{4} + \frac{1}{4}(-1)^x + C\<br>&amp;= -\frac{(-1)^xx}{2} + C<br>\end{aligned}<br>$$<br>回到上式：<br>$$<br>\begin{aligned}<br>\sum (-1)^xx^2\delta x &amp;= -\frac{x^2(-1)^x}{2} + \frac{(-1)^xx}{2} + C\<br>&amp;= -\frac{(-1)^xx(x - 1)}{2} + C<br>\end{aligned}<br>$$<br>给这个和式加上下界：<br>$$<br>\begin{aligned}<br>\sum_{x = 1}^n (-1)^xx^2 &amp;= -\frac{(-1)^{n + 1}n(n + 1)}{2} + -\frac{(-1)^1\cdot 0 \cdot 1}{2} \<br>&amp;= \frac{(-1)^nn(n + 1)}{2}<br>\end{aligned}<br>$$<br>以上的过程如行云流水一般地系统化和顺畅，只要熟悉我们拆分出指数项，然后对多项式项不断使用差分降次——这其实是分部积分的技巧，但是得益于有限微积分和微积分的联系我们得以直接拿来用了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，基于整数建立起来的有限微积分虽然不一定有传统的微积分那么好的性质，但是依然可以系统地高效地处理很多的求和问题，我们在有限微积分的公式推导中还顺便导出了平方和公式，裂项公式和等比数列公式等，而这一切公式的导出在有限微积分的背景下是那么地自然，以至于让人无法相信第一个属于小学奥数，第二个属于初中数学，而最后一个要在高中才能教到。虽然这也和我们独到的证明方法有关（一般来说这三个公式分别需要用到归纳法，叠缩和扰动法证明），但是可以预见的是，有限微积分的确在和式的处理上具有<strong>提纲掣领</strong>的作用，不容小觑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
