<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="什么是次线性算法？如何衡量算法的效率？一般来说，问题（以及对应的算法）可以分为以下几类：  不可判定问题。这种问题不存在算法。 指数时间可解。这种问题虽然存在算法但是就目前我们的技术水平，对于大输入，它们没办法在可接受的时间内返回结果。 多项式时间可解。这些算法可以在现在的电脑上较为高效地运行。 线性时间可解。这是大多数人认为的最高效算法，一般来说不会有比这更高效的了（读取输入就是线性的，不读完输">
<meta property="og:type" content="article">
<meta property="og:title" content="次线性算法与有序判定问题">
<meta property="og:url" content="https://alan20210202.github.io/2020/07/02/Sublinear/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="什么是次线性算法？如何衡量算法的效率？一般来说，问题（以及对应的算法）可以分为以下几类：  不可判定问题。这种问题不存在算法。 指数时间可解。这种问题虽然存在算法但是就目前我们的技术水平，对于大输入，它们没办法在可接受的时间内返回结果。 多项式时间可解。这些算法可以在现在的电脑上较为高效地运行。 线性时间可解。这是大多数人认为的最高效算法，一般来说不会有比这更高效的了（读取输入就是线性的，不读完输">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-02T09:04:15.556Z">
<meta property="article:modified_time" content="2020-07-12T03:17:55.796Z">
<meta property="article:author" content="Chengyuan Ma">
<meta property="article:tag" content="PACT">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/2020/07/02/Sublinear/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>次线性算法与有序判定问题 | Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AC%A1%E7%BA%BF%E6%80%A7%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是次线性算法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">查询模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98%EF%BC%88Sortedness-Problem%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">有序判定问题（Sortedness Problem）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.</span> <span class="nav-text">修改后的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.</span> <span class="nav-text">二元数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90"><span class="nav-number">3.3.1.</span> <span class="nav-text">初步分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">3.3.3.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.3.4.</span> <span class="nav-text">时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5"><span class="nav-number">3.4.</span> <span class="nav-text">一般情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">分析</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/02/Sublinear/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          次线性算法与有序判定问题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-02 17:04:15" itemprop="dateCreated datePublished" datetime="2020-07-02T17:04:15+08:00">2020-07-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-12 11:17:55" itemprop="dateModified" datetime="2020-07-12T11:17:55+08:00">2020-07-12</time>
      </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="什么是次线性算法？"><a href="#什么是次线性算法？" class="headerlink" title="什么是次线性算法？"></a>什么是次线性算法？</h1><p>如何衡量算法的效率？一般来说，问题（以及对应的算法）可以分为以下几类：</p>
<ol>
<li>不可判定问题。这种问题不存在算法。</li>
<li>指数时间可解。这种问题虽然存在算法但是就目前我们的技术水平，对于大输入，它们没办法在可接受的时间内返回结果。</li>
<li>多项式时间可解。这些算法可以在现在的电脑上较为高效地运行。</li>
<li>线性时间可解。这是大多数人认为的最高效算法，一般来说不会有比这更高效的了（读取输入就是线性的，不读完输入怎么计算输出？）</li>
<li><strong>次线性时间算法</strong>。“次线性”(sublinear)即“线性以下”，指在利用低于与输入线性的资源（可以是时间也可以是空间）的情况下解决问题的一类算法。这类算法有着非常不可思议的特性：它甚至都不会看完完整的输入！</li>
</ol>
<p>为什么我们需要次线性算法？</p>
<p>大数据时代我们要处理的数据是在是太多了，光是谷歌一天就会产生20PB的数据，我们根本没有足够的时空资源来哪怕运行线性的算法或者把它们全部过一遍！但是我们又希望从这些数据中挖掘有价值的结论，就只能求助于次线性算法了。</p>
<p>因为次线性算法没法看到完整的输入，给出错误的结果自然是情有可原的（在精确解没法在次线性时间内算出的情况下）。因此，次线性算法多是<strong>近似算法</strong>。同时，因为如果一个算法是确定性的，对手就可以预判这个算法会看那部分输入，并针对这个造出会让算法100%翻车的数据，因此<strong>随机化</strong>在次线性算法的设计也经常出现。</p>
<h1 id="查询模型"><a href="#查询模型" class="headerlink" title="查询模型"></a>查询模型</h1><p>好，既然次线性算法不能把输入完整地读一遍，那么要怎么样才能获取输入的信息呢？我们将次线性算法获取输入信息的方式称为<strong>查询</strong>（query）。而算法的难易自然和可以进行的查询方式有着很大的关系，因此我们还需要一组规则定义在一个问题中可以进行何种方式的查询，这种规则称一个问题的<strong>查询模型</strong>（query model）。例如，在以数组为输入的问题当中，常见的查询方式是按照一个下标询问对应的值，在以图为输入的问题当中，查询可以是按照两点查询边权……可以看到，查询模型是因问题而异的。</p>
<h1 id="有序判定问题（Sortedness-Problem）"><a href="#有序判定问题（Sortedness-Problem）" class="headerlink" title="有序判定问题（Sortedness Problem）"></a>有序判定问题（Sortedness Problem）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>输入：</strong>一个$n$个元素的数组$A$。</p>
<p><strong>查询模型：</strong>对于一个整数$1\le i \le n$，查询$A_i$的值。</p>
<p><strong>目标：</strong>在尽量少的时间内（假设一次查询时$\mathcal{O}(1)$的）<strong>判断这个数组是否是有序</strong>（此处单指<strong>升序</strong>）的。</p>
<p>很显然，任何一个确定性的算法都必须进行$\Omega(n)$次查询才能解决这个问题（不然肯定会有漏看的）。</p>
<p>因此我们退而求其次：如果运用随机化的话，我们能不能在$o(n)$次查询之内给出正确概率至少为$\frac{1}{2}+\epsilon\ (\epsilon &gt;0)$的答案呢？</p>
<p>（正确概率在这里只要大于$\frac{1}{2}$就行，精确的值没有意义，因为我们总是可以重复运行不靠谱的算法提高正确率）</p>
<p>答案还是不行（证明课上似乎没讲？）</p>
<p>那我们怎么办？只好稍微把题目修改一下，再退而求其次看看能不能有高效的<strong>近似算法</strong>了。</p>
<h2 id="修改后的定义"><a href="#修改后的定义" class="headerlink" title="修改后的定义"></a>修改后的定义</h2><p>我们不妨寻找这么一个算法，它</p>
<ol>
<li>在数组有序的时候输出是</li>
<li>在数组“非常无序”的时候输出否</li>
<li>而对于那种非常接近有序的数组，我们干脆不管。</li>
</ol>
<p>设计这样的算法显然比设计能够精确解决这个问题的算法要容易多了。</p>
<p>那么怎么样算是“非常无序”，怎么样算是“接近有序”呢？显然，我们需要在数学上给予这些描述严谨的定义。</p>
<p><strong>定义：</strong>对于$\epsilon\in(0,1)$，如果需要至少修改$\epsilon n$个数才能让数组$A$变为有序，那么称数组$A$是$\epsilon$无序（$\epsilon$-far from sorted）的。</p>
<p>那么我们就可以进一步精炼我们上面的问题了：我们需要设计一个算法，使其</p>
<ol>
<li>在$A$有序的时候输出是</li>
<li>在$A$ $\epsilon$无序的时候输出否</li>
</ol>
<p>（$\epsilon$是算法的一个参数）</p>
<p>从这里其实可以看到对于近似算法的一种设计思路：对于数值型的问题，我们通过对于最优解的放缩定义了近似比$\alpha$，而对于判定型的问题，我们试图放宽需要判定的条件。在上面的问题当中我们相当于变相假设，或者说承诺了$A$要么是有序要么是$\epsilon$无序的，因此这种问题被称作promise problem。</p>
<h2 id="二元数组"><a href="#二元数组" class="headerlink" title="二元数组"></a>二元数组</h2><p>我们先从最简单的情形开始分析：如果数组只有$0$和$1$两种元素呢？</p>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>显然此时数组有序等价于所有的$0$都在$1$前面。</p>
<p>我们不妨定义两个集合，$L_1$和$R_0$。如果将数组里的元素从左到右排列，$L_1$表示最靠左的$\frac{\epsilon n}{2}$个$1$的下标集合，$R_0$表示最靠右的$\frac{\epsilon n}{2}$个$0$的下标集合。</p>
<p>显然在数组有序时，$L_1$整体都在$R_0$右边。而当数组不有序时，有可能：</p>
<ol>
<li>$L_1$和$R_0$的区间重叠。</li>
<li>$L_1$在$R_0$的左边。</li>
</ol>
<p>接下来我们证明：</p>
<p><strong>引理：</strong>如果$A$是$\epsilon$无序的，那么$L_1$必定在$R_0$左边且不重叠。</p>
<p><strong>证明：</strong>我们使用反证法，不妨假设$L_1$和$R_0$有重叠的部分：<br>$$<br>0,0,\cdots,\rlap{\overbrace{1,\cdots,1,0,1}^{L_1} }1,\cdots,1,\underbrace{ {\color{blue}{0} },{\color{red}{1} },0,\cdots,0}_{R_0},\cdots1,1<br>$$</p>
<p>$\color{red}1$是$L_1$中最右边的$1$，$\color{blue}0$是$R_0$中最左边的$0$。</p>
<p>由$L_1,R_0$的定义可知，$\color{red}1$左侧的$1$的数量严格小于$\frac{\epsilon n}{2}$，$\color{blue}0$右侧的$0$的数量也严格小于$\frac{\epsilon n}{2}$。而注意到如果把$\color{red}1$的左侧$1$改成$0$，把$\color{blue}0$右侧的$0$的改成$1$，那么数组就变得有序了，而此时我们修改的元素数量严格小于$\epsilon n$，这和数组是$\epsilon$无序的前提是矛盾的。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>接下来我们给出能够以$1-\delta$的成功率判定二元数组有序性的算法：</p>
<ol>
<li>从数组当中随机选取$t=\frac{2}{\epsilon}\ln\frac{2}{\delta}$个下标$i_1,\cdots,i_t$（为了简化分析，允许下标重复）。</li>
<li>查询$A_{i_1},\cdots, A_{i_t}$的值。</li>
<li>如果在$\left{A_{i_1},\cdots, A_{i_t}\right}$当中发现了逆序对，输出否，否则输出是。</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很显然，如果数组是有序的，那么我们的算法一定会输出是，成功率$1&gt;1-\delta$。</p>
<p>而如果数组是$\epsilon$-无序的，为了证明此时的成功率至少为$1-\delta$，我们只需要证明<br>$$<br>\operatorname{Pr}[\text{wrong answer}] \le \delta<br>$$<br>即错误（输出了是）概率不大于$\delta$。</p>
<p>设随机事件$E_L$表示在随机选取的$t$个下标中，至少有一个下标来自$L_1$，$E_R$表示至少有一个下标来自$R_0$。</p>
<p>那么由之前的引理，如果$E_L\cap E_R$，我们一定找得到逆序对。</p>
<p>因此只有可能在$\overline{E_L\cap E_R}$才有可能出错：<br>$$<br>\begin{aligned}<br>    \operatorname{Pr}[\text{wrong answer}] \le \operatorname{Pr}\left[\overline{E_L}\cup\overline{E_R} \right] \le \operatorname{Pr}\left[\overline{E_L}\right] +  \operatorname{Pr}\left[\overline{E_R}\right]<br>\end{aligned}<br>$$<br>而<br>$$<br>\begin{aligned}<br>    \operatorname{Pr}\left[\overline{E_L}\right] &amp;= \left(1-\frac{\left|L_1\right|}{n}\right) ^ t \<br>    &amp;= \left(1-\frac{\epsilon}{2}\right)^{\frac{2}{\epsilon}\ln\frac{2}{\delta}} \<br>    &amp;\le \left(e^{-\frac{\epsilon}{2}}\right)^{\frac{2}{\epsilon}\ln\frac{2}{\delta}} \<br>    &amp;= \frac{\delta}{2}<br>\end{aligned}<br>$$<br>倒数第二步我们运用了不等式$1+x\le e^x$。</p>
<p>同理可证$\operatorname{Pr}\left[\overline{E_R}\right] \le \frac{\delta}{2}$，因此<br>$$<br>\operatorname{Pr}[\text{wrong answer}] \le \operatorname{Pr}\left[\overline{E_L}\right] +  \operatorname{Pr}\left[\overline{E_R}\right] \le \frac{\delta}{2} + \frac{\delta}{2} = \delta<br>$$<br>证毕。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>随机采样花费的时间复杂度为$\mathcal{O}(t)$。</p>
<p>查询子数组花费的时间复杂度也是$\mathcal{O}(t)$。</p>
<p>而在子数组当中查找逆序对也可以被优化成$\mathcal{O}(t)$，实现的方法有很多，例如可以计算$1$的下标的最小值和$0$的下标的最大值进行比较等。</p>
<p>因此这个算法的时间复杂度就是$\mathcal O(t) = \mathcal O\left(\frac{1}{\epsilon}\ln\frac{1}{\delta}\right)$，和$n$无关。</p>
<h2 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h2><p>接下来我们来看数组元素可以是任意数字的情况。</p>
<p>我们之前随机采样的想法还能继续沿用吗？</p>
<p>考虑如下情况：<br>$$<br>3,2,1{\color{red}|}6,5,4{\color{red}|}9,8,7<br>$$<br>虽然这个数组是$\frac{2}{3}$无序的，但是如果我的随机采样在每个段中只挑了一个元素，那采样出来的子序列却一定是有序的，我们的算法就被糊弄过去了。</p>
<p>这就是问题所在：如果我们把一个数组分成若干段“总体有序，但局部无序”的连续段，显然这样的段最多可以有$\mathcal O(n)$个。而为了能够在子序列当中找到逆序对，就必须从同一个段当中至少选两个数。而由生日悖论可知，为了大概率确保能从一个段中选两个数，我们必须至少随机选$\mathcal O\left(\sqrt n\right)$个数——这让我们之前的分析几乎废掉。</p>
<p>那怎么办呢？</p>
<p>考虑一个有序的数组所具有的性质。在算法层面，一个熟悉的性质便是：<strong>可以进行二分查找</strong>。</p>
<p>这给我们一个思路：如果我们不管三七二十一在给定的数组上跑二分，如果二分翻车了，那么数组一定是无序的，如果二分没翻车，数组或许就是有序的。</p>
<p>如何定义二分有没有“翻车”？或者说，如何定义一次正常的二分？</p>
<p>引入<em>一致二分查找</em>（Consistent Binary Search）的概念，如果对于一次二分查找，</p>
<ol>
<li>我最后找到了我要找的那个数（也就是说，如果我要找的是$A_i$，而我的二分最后终止于下标$i$），</li>
<li>假设二分的左右端点和终点分别为$l,r,m$，二分的过程中$A_l &lt; A_m &lt; A_r$始终成立，</li>
</ol>
<p>那么我们称这次二分查找是“一致的”或“相容的”（我觉得翻译成哪个似乎都不大合适）。</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>在二分思想的指引下我们提出如下的算法：</p>
<ol>
<li>随机选择一个下标$i$并查询$A_i$的值。</li>
<li>二分查找$A_i$。</li>
<li>如果这次二分查找是一致的，那么输出是，反之输出否。</li>
</ol>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>引理：</strong>如果对于$A_i$和$A_j$的二分查找都是一致的，而且$i&lt;j$，一定有$A_i&lt;A_j$。</p>
<p><strong>证明：</strong>虽然两次二分查找中前几层的搜索区间可能相同，但由于$i &lt; j$，到了某一层一定会出现$A_i$往左边，$A_j$往右边的分歧。假设该层搜索区间的中点是$A_m$，显然对$A_i$的二分搜索之所以在这层之后往左走是因为$A_i &lt; A_m$，同理可知$A_j&gt;A_m$，将二式组合引理便得证。</p>
<p>假设$C$表示所有对下标对应的数进行的二分搜索是一致的下标的集合。则由刚刚的引理，由$C$中下标组成的原数组的子序列一定是有序的。因为原数组是$\epsilon$无序的，因此必然有$|C|&lt;(1-\epsilon) n$（可以通过反证法证明）。</p>
<p>这个结论有什么意义呢？要知道我们的算法在原数组有序的时候一定输出正确的结果，而在原数组无序时，我们算法只有在抽到$C$中的下标时才会做出误判。因此我们算法的错误率的上界为$1-\epsilon$。</p>
<p>在得出这个上界之后，我们就可以改进我们的算法了：</p>
<ol>
<li>将之前的算法运行$k=\frac{1}{\epsilon}\ln\frac{1}{\delta}$遍。</li>
<li>如果$k$次运行的结果都为是，则输出是，反之则输出否。</li>
</ol>
<p>这样的错误率是多少呢？<br>$$<br>\begin{aligned}<br>    \operatorname{Pr}[\text{wrong answer}] &amp;\le \left(1-\epsilon\right)^k \<br>    &amp;= \left(1-\epsilon\right)^{\frac{1}{\epsilon}\ln\frac{1}{\delta}} \<br>    &amp;\le \left(e^{-\epsilon}\right)^{\frac{1}{\epsilon}\ln\frac{1}{\delta}} \<br>    &amp; = \delta<br>\end{aligned}<br>$$<br>因此正确率至少为$1-\delta$，符合我们的要求。而这个算法的时间复杂度是$\mathcal O\left(\frac{1}{\epsilon}\ln\frac{1}{\delta}\log n\right)$，也是相当优秀的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PACT/" rel="tag"># PACT</a>
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/02/PACT0701/" rel="prev" title="PACT 07/01 任务调度问题">
                  <i class="fa fa-chevron-left"></i> PACT 07/01 任务调度问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/07/03/PACT0702/" rel="next" title="PACT 07/02 TSP问题">
                  PACT 07/02 TSP问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
